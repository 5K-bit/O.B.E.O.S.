#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import os
import socket
import sys
import time
from typing import Any


def _sock_path() -> str:
    return os.environ.get("OBEOS_SOCKET", "/run/obeos.sock")


def _call_engine(command: str, args: list[Any], *, request_id: str | None = None) -> dict[str, Any]:
    req: dict[str, Any] = {"command": command, "args": args}
    if request_id is not None:
        req["request_id"] = request_id

    data = (json.dumps(req, separators=(",", ":"), ensure_ascii=False) + "\n").encode("utf-8")

    with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as s:
        s.connect(_sock_path())
        s.sendall(data)
        buf = b""
        while b"\n" not in buf:
            chunk = s.recv(65536)
            if not chunk:
                break
            buf += chunk
        line = buf.split(b"\n", 1)[0].decode("utf-8", errors="replace")
        return json.loads(line) if line else {"ok": False, "error": "no_response"}


def _print(obj: Any, *, as_json: bool) -> None:
    if as_json:
        sys.stdout.write(json.dumps(obj, indent=2, sort_keys=True) + "\n")
        return
    if isinstance(obj, (dict, list)):
        sys.stdout.write(json.dumps(obj, indent=2, sort_keys=True) + "\n")
    else:
        sys.stdout.write(f"{obj}\n")


def main() -> int:
    ap = argparse.ArgumentParser(prog="bf", description="OBEOS client (talks only to the engine)")
    ap.add_argument("--json", action="store_true", help="Print JSON output")

    sp = ap.add_subparsers(dest="cmd", required=True)

    sp.add_parser("status")

    p_build = sp.add_parser("build")
    p_build.add_argument("args", nargs=argparse.REMAINDER)
    p_build.add_argument("--follow", action="store_true", help="Poll until job completes")
    p_build.add_argument("--poll", type=float, default=0.25, help="Poll interval seconds")

    p_jobs = sp.add_parser("jobs")
    p_jobs.add_argument("limit", nargs="?", default="50")
    p_jobs.add_argument("status", nargs="?", default="")

    p_logs = sp.add_parser("logs")
    p_logs.add_argument("mode", nargs="?", default="last")
    p_logs.add_argument("value", nargs="?", default="1h")

    p_mem = sp.add_parser("memory")
    p_mem.add_argument("sub", nargs="?", default="summary")

    sp.add_parser("shutdown")

    args = ap.parse_args()

    try:
        if args.cmd == "status":
            resp = _call_engine("status", [])
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2

        if args.cmd == "build":
            resp = _call_engine("build", list(args.args))
            _print(resp, as_json=args.json)
            if not resp.get("ok"):
                return 2
            if not args.follow:
                return 0
            job_id = (resp.get("result") or {}).get("job_id")
            if not isinstance(job_id, int):
                return 0
            while True:
                j = _call_engine("jobs", [200]).get("result", {}).get("jobs", [])
                job = next((x for x in j if x.get("id") == job_id), None)
                if job is None:
                    time.sleep(args.poll)
                    continue
                if job.get("status") in ("completed", "failed"):
                    _print({"job": job}, as_json=args.json)
                    return 0 if job.get("status") == "completed" else 2
                time.sleep(args.poll)

        if args.cmd == "jobs":
            limit = int(args.limit)
            status = args.status or ""
            call_args: list[Any] = [limit]
            if status:
                call_args.append(status)
            resp = _call_engine("jobs", call_args)
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2

        if args.cmd == "logs":
            resp = _call_engine("logs", [args.mode, args.value])
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2

        if args.cmd == "memory":
            resp = _call_engine("memory", [args.sub])
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2

        if args.cmd == "shutdown":
            resp = _call_engine("shutdown", [])
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2
    except FileNotFoundError:
        sys.stderr.write(f"Engine socket not found: {_sock_path()}\n")
        return 2
    except ConnectionRefusedError:
        sys.stderr.write(f"Engine not accepting connections on: {_sock_path()}\n")
        return 2
    except Exception as e:  # noqa: BLE001
        sys.stderr.write(f"bf error: {e}\n")
        return 2

    return 2


if __name__ == "__main__":
    raise SystemExit(main())

