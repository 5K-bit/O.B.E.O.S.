#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import os
import socket
import sys
import time
from typing import Any


def _sock_path() -> str:
    return os.environ.get("OBEOS_SOCKET", "/run/obeos.sock")


def _call_engine(command: str, args: list[Any], *, request_id: str | None = None) -> dict[str, Any]:
    req: dict[str, Any] = {"command": command, "args": args}
    if request_id is not None:
        req["request_id"] = request_id

    data = (json.dumps(req, separators=(",", ":"), ensure_ascii=False) + "\n").encode("utf-8")

    with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as s:
        s.connect(_sock_path())
        s.sendall(data)
        buf = b""
        while b"\n" not in buf:
            chunk = s.recv(65536)
            if not chunk:
                break
            buf += chunk
        line = buf.split(b"\n", 1)[0].decode("utf-8", errors="replace")
        return json.loads(line) if line else {"ok": False, "error": "no_response"}

def _subscribe(patterns: list[str] | None = None, *, last_event_id: int | None = None) -> tuple[socket.socket, Any]:
    """
    Opens a long-lived subscription connection.
    Returns (socket, fileobj) where fileobj yields newline-delimited JSON frames.
    """
    req: dict[str, Any] = {"command": "subscribe", "args": patterns or ["*"]}
    if last_event_id is not None:
        req["last_event_id"] = int(last_event_id)

    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(_sock_path())
    s.sendall((json.dumps(req, separators=(",", ":"), ensure_ascii=False) + "\n").encode("utf-8"))
    f = s.makefile("r", encoding="utf-8", newline="\n")
    return s, f


def _print(obj: Any, *, as_json: bool) -> None:
    if as_json:
        sys.stdout.write(json.dumps(obj, indent=2, sort_keys=True) + "\n")
        return
    if isinstance(obj, (dict, list)):
        sys.stdout.write(json.dumps(obj, indent=2, sort_keys=True) + "\n")
    else:
        sys.stdout.write(f"{obj}\n")


def main() -> int:
    ap = argparse.ArgumentParser(prog="bf", description="OBEOS client (talks only to the engine)")
    ap.add_argument("--json", action="store_true", help="Print JSON output")

    sp = ap.add_subparsers(dest="cmd", required=True)

    sp.add_parser("status")

    p_build = sp.add_parser("build")
    p_build.add_argument("args", nargs=argparse.REMAINDER)
    p_build.add_argument("--follow", action="store_true", help="Follow job updates (engine subscription; fallback: polling)")
    p_build.add_argument("--poll", type=float, default=0.25, help="Poll interval seconds")

    p_jobs = sp.add_parser("jobs")
    p_jobs.add_argument("limit", nargs="?", default="50")
    p_jobs.add_argument("status", nargs="?", default="")

    p_logs = sp.add_parser("logs")
    p_logs.add_argument("mode", nargs="?", default="last")
    p_logs.add_argument("value", nargs="?", default="1h")

    p_mem = sp.add_parser("memory")
    p_mem.add_argument("sub", nargs="?", default="summary")

    sp.add_parser("shutdown")

    args = ap.parse_args()

    try:
        if args.cmd == "status":
            resp = _call_engine("status", [])
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2

        if args.cmd == "build":
            sub_sock = None
            sub_file = None
            if args.follow:
                try:
                    # Subscribe first so we can't miss fast jobs.
                    sub_sock, sub_file = _subscribe(["job.*", "engine.shutdown.*", "command.*"])
                    first = sub_file.readline()
                    ack = json.loads(first) if first else {"ok": False, "error": "no_subscribe_ack"}
                    if not ack.get("ok") or ack.get("type") != "subscribed":
                        try:
                            sub_sock.close()
                        except Exception:
                            pass
                        sub_sock = None
                        sub_file = None
                except Exception:
                    sub_sock = None
                    sub_file = None

            resp = _call_engine("build", list(args.args))
            _print(resp, as_json=args.json)
            if not resp.get("ok"):
                if sub_sock:
                    try:
                        sub_sock.close()
                    except Exception:
                        pass
                return 2

            if not args.follow:
                return 0

            job_id = (resp.get("result") or {}).get("job_id")
            if not isinstance(job_id, int):
                if sub_sock:
                    try:
                        sub_sock.close()
                    except Exception:
                        pass
                return 0

            # Event-driven follow (preferred)
            if sub_file is not None:
                try:
                    while True:
                        line = sub_file.readline()
                        if not line:
                            break
                        msg = json.loads(line)
                        if msg.get("type") != "event":
                            continue
                        ev = msg.get("event") or {}
                        ev_type = ev.get("type")
                        payload = ev.get("payload") or {}
                        if payload.get("job_id") != job_id:
                            continue
                        if ev_type in ("job.created", "job.started"):
                            _print({"event": ev}, as_json=args.json)
                        if ev_type in ("job.finished", "job.failed"):
                            # Fetch final job record for authoritative status/result.
                            jobs = _call_engine("jobs", [200]).get("result", {}).get("jobs", [])
                            job = next((x for x in jobs if x.get("id") == job_id), None)
                            _print({"job": job, "terminal_event": ev}, as_json=args.json)
                            return 0 if (job or {}).get("status") == "completed" else 2
                finally:
                    try:
                        sub_sock.close()
                    except Exception:
                        pass

            # Fallback polling
            while True:
                j = _call_engine("jobs", [200]).get("result", {}).get("jobs", [])
                job = next((x for x in j if x.get("id") == job_id), None)
                if job is None:
                    time.sleep(args.poll)
                    continue
                if job.get("status") in ("completed", "failed"):
                    _print({"job": job}, as_json=args.json)
                    return 0 if job.get("status") == "completed" else 2
                time.sleep(args.poll)

        if args.cmd == "jobs":
            limit = int(args.limit)
            status = args.status or ""
            call_args: list[Any] = [limit]
            if status:
                call_args.append(status)
            resp = _call_engine("jobs", call_args)
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2

        if args.cmd == "logs":
            resp = _call_engine("logs", [args.mode, args.value])
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2

        if args.cmd == "memory":
            resp = _call_engine("memory", [args.sub])
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2

        if args.cmd == "shutdown":
            resp = _call_engine("shutdown", [])
            _print(resp, as_json=args.json)
            return 0 if resp.get("ok") else 2
    except FileNotFoundError:
        sys.stderr.write(f"Engine socket not found: {_sock_path()}\n")
        return 2
    except ConnectionRefusedError:
        sys.stderr.write(f"Engine not accepting connections on: {_sock_path()}\n")
        return 2
    except Exception as e:  # noqa: BLE001
        sys.stderr.write(f"bf error: {e}\n")
        return 2

    return 2


if __name__ == "__main__":
    raise SystemExit(main())

